/**
 *题目：给出nxm的棋盘，有多少种方法放置两个互相攻击的皇后（在同一行、同一列、同对角线都会相互攻击）？
 *0<= (n,m) <= 10^6
 *
 *分析：
 *同一行：A(n,m)
 *同一列：B(n,m)
 *同一对角线：D(n,m)
 *answer = A(n,m) + B(n,m) + D(n,m)
 *
 *A(n,m)第一次放时有nm个选择，之后只能放在第一个皇后的同一行(m-1),共nm(m-1)
 *B(n,m)第一次放时有nm个选择，之后只能放在第一个皇后的同一列(n-1),共nm(n-1)
 *D(n,m)设n<=m,则所有对角线的长度是1，2,3,4,5,..,n-1,n,n,...,n,n-1,n-2,...,1
 *其中有m-n+1个n,对于第i个对角线，有i(i-1)个放置方法。
 *D(n,m) = 2 * {2 * sum{i:[1, n-1]; i(i-1)} + (m-n+1)n(n-1)}
 *	
 *sum{i:[1, n-1]; i^2} - sum{i:[1, n-1]; i} = n(n-1)(2n-1)/6 - n(n-1)/2 = n(n-1)(2n-4)/6
 *
 *D(n,m) = 2*{n(n-1)(2n-4)/3 + (m-n+1)n(n-1)} = 2*n*(n-1)*(3*m-n-1)/3
 *因为A(n,m) + B(n,m) = n*m*(n+m-2)
 */

#include<iostream>
#include<stdio.h>
#include<algorithm>
using namespace std;

int main()
{
	unsigned long long n,m;//防止精度的溢出
	while(cin>>n>>m){
		if(n+m == 0) break;
		
		if(n>m) swap(n,m);//假设n<m
		
		cout<< n*m*(m+n-2) + 2*n*(n-1)*(3*m-n-1)/3 <<endl;
	
	}

	return 0;
}

/**
 *总结，如果可以，一定要将公式化简的最简模式，可以之间加减乘除计算的，
 *不用递推公式和数组。还有计算时注意数据的范围，防止在计算的过程中超出C++
 *语言的精度，精度包括上溢和下溢，上溢是超过最大值，下溢是将小的数近似为0
 *
 */
 





 
